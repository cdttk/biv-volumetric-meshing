# This script converts the text model output file from the mesh fitting code to vtk files

# !/usr/bin/env python3
import argparse
import configparser
import logging
import os
import numpy as np
import time
import pandas as pd
from pathlib import Path
import re
import sys

from .BiVFitting import BiventricularModel
from .BiVFitting import Surface

logger = logging.getLogger(__name__)

def write_vtk_polydata(filename, vertices, **kwargs):
    """Writes mesh as .vtk file format for Paraview (Kitware (c)) visualisation software.
    ----------
    Author: LDT, modified from code given by Debbie Zhao
    ----------
    Input:
    ----------
    filename: str
        path to output file with .vtk extension
    vertices: ndarray
        numpy Nx3 array of the coordinates of the mesh vertices
    (OPTIONAL) faces: ndarray
        numpy Nx3 (triangular) or Nx4 (quadrilateral) array of the faces
    """
    faces = kwargs.get('faces', None)
    vertices = np.asarray(vertices)
    nv = vertices.shape[0]

    if faces is not None:
        nf = faces.shape[0]
        ns = faces.shape[1]

        with open(filename, 'w') as f:

            f.write('# vtk DataFile Version 4.2\n')
            f.write('Legacy vtk file generated by python\n')
            f.write('ASCII\n')
            f.write('DATASET POLYDATA\n')

            # write vertex data
            f.write('\nPOINTS %u float\n' % nv)
            for vertex in vertices:
                f.write('%f %f %f\n' % (vertex[0], vertex[1], vertex[2]))

            # write face (polygon) data
            f.write('\nPOLYGONS %u %u\n' % (nf, nf * (ns + 1)))
            if ns == 3:  # triangle
                [f.write('3 %u %u %u\n' % (face[0], face[1], face[2])) for face in faces]
            elif ns == 4:  # quadrangle
                [f.write('4 %u %u %u %u\n' % (face[0], face[1], face[2], face[3])) for face in
                 faces]

    else:
        with open(filename, 'w') as f:

            f.write('# vtk DataFile Version 4.2\n')
            f.write('Legacy vtk file generated by python\n')
            f.write('ASCII\n')
            f.write('DATASET POLYDATA\n')

            # write vertex data
            f.write('\nPOINTS %u float\n' % nv)
            for vertex in vertices:
                f.write('%f %f %f\n' % (vertex[0], vertex[1], vertex[2]))


def save_mesh_as_vtk(model_dir: str, mesh_dir: str, timeframe_num: int, force_overwrite: bool):
    """
    The mesh files in .txt format in folder will be written as vtk files in the same
    folder. A different mesh is created for each label so that they can be visualized separately in
    paraview.

    Args:
        model_dir: Path to the folder where the heart atlas models are.
        mesh_dir: Path to the output folder of the mesh fitting code. This is where the meshes
            for an individual heart are.

    Returns:

    """
    subject_id = mesh_dir.split(os.sep)[-3]

    mesh_files = sorted([filename for filename in os.listdir(mesh_dir) if
                         subject_id + '_model_timeframe' in filename])

    for file in mesh_files:
        # Extract time frame id
        time_frame_id = int((re.search(r'_timeframe(.*).txt', file)).group(1))

        if timeframe_num is not None and timeframe_num != time_frame_id:
            logger.debug('subject {}, timeframe {}: skipping, timeframe not requested'.format(subject_id, time_frame_id))
            continue

        pv_file = os.path.join(mesh_dir, 'Mesh_pulmonary_valve_timeframe' + format(time_frame_id, '03') + '.vtk')
        if os.path.exists(pv_file) and not force_overwrite:
            logger.debug('subject {}, timeframe {}: skipping, mesh files exist'.format(subject_id, time_frame_id))
            continue

        # read the mesh from text file as a biventricular model
        shifting_model = BiventricularModel(model_dir, os.path.join(mesh_dir, file))

        fitted_nodes = pd.read_csv(
            os.path.join(mesh_dir, file), sep=r'\s+', skiprows=0).values[:, :3]
        shifting_model.update_control_mesh(fitted_nodes)

        # Extract data for LV endo
        faces_lv_endo = shifting_model.get_surface_faces(Surface.LV_ENDOCARDIAL)
        x = np.array(shifting_model.et_pos[:, 0]).T
        y = np.array(shifting_model.et_pos[:, 1]).T
        z = np.array(shifting_model.et_pos[:, 2]).T
        data = np.vstack((x, y, z)).T
        write_vtk_polydata(os.path.join(mesh_dir, 'Mesh_LV_endo_timeframe' + format(time_frame_id,
                                                                                    "03") +
                                        '.vtk'),
                           data, faces=faces_lv_endo)

        # RV free wall
        faces_rv_fw = shifting_model.get_surface_faces(Surface.RV_FREEWALL)
        write_vtk_polydata(
            os.path.join(mesh_dir, 'Mesh_RV_FW_timeframe' + format(time_frame_id, "03") + '.vtk'),
            data, faces=faces_rv_fw)

        # RV septum
        faces_rv_septum = shifting_model.get_surface_faces(Surface.RV_SEPTUM)
        write_vtk_polydata(os.path.join(mesh_dir,
                                        'Mesh_RV_septum_timeframe' + format(time_frame_id,
                                                                            "03") + '.vtk'), data,
                           faces=faces_rv_septum)

        # epicardium
        faces_epi = shifting_model.get_surface_faces(Surface.EPICARDIAL)
        write_vtk_polydata(
            os.path.join(mesh_dir, 'Mesh_epi_timeframe' + format(time_frame_id, "03") + '.vtk'),
            data, faces=faces_epi)

        # mitral valve
        faces_mitral = shifting_model.get_surface_faces(Surface.MITRAL_VALVE)
        write_vtk_polydata(os.path.join(mesh_dir,
                                        'Mesh_mitral_valve_timeframe' + format(time_frame_id,
                                                                               "03") + '.vtk'),
                           data, faces=faces_mitral)

        # aorta valve
        faces_aorta = shifting_model.get_surface_faces(Surface.AORTA_VALVE)
        write_vtk_polydata(os.path.join(mesh_dir,
                                        'Mesh_aorta_valve_timeframe' + format(time_frame_id,
                                                                              "03") + '.vtk'),
                           data, faces=faces_aorta)

        # tricuspid valve
        faces_tricuspid = shifting_model.get_surface_faces(Surface.TRICUSPID_VALVE)
        write_vtk_polydata(os.path.join(mesh_dir,
                                        'Mesh_tricuspid_valve_timeframe' + format(time_frame_id,
                                                                                  "03") + '.vtk'),
                           data, faces=faces_tricuspid)

        # pulmonary valve
        faces_pulmonary = shifting_model.get_surface_faces(Surface.PULMONARY_VALVE)
        write_vtk_polydata(os.path.join(mesh_dir,
                                        'Mesh_pulmonary_valve_timeframe' + format(time_frame_id,
                                                                                  "03") + '.vtk'),
                           data, faces=faces_pulmonary)


def main():
    parser = argparse.ArgumentParser()

    parser.add_argument('--profile', '-p', action='store', default='default', help='config profile to be used')
    parser.add_argument('--job', '-j', action='store', default='default', help='job identifier')
    parser.add_argument('--force', '-f', action='store_true', default=False, help='force overwrite')

    parser.add_argument('--data-dir', '-d', action='store', help='path to data directory')
    parser.add_argument('--output-dir', '-o', action='store', default='Mesh_Outputs', help='name of output directories')

    parser.add_argument('--instance', '-i', type=int, action='store', default=2, help='instance to be processed')

    parser.add_argument('--all', '-a', action='store_true', help='process all subjects')
    parser.add_argument('--subject', '-s', action='store', help='subject id to be processed')
    parser.add_argument('--start', '-S', action='store', type=int, help='index of first subject id to be processed')
    parser.add_argument('--number', '-n', action='store', type=int, help='number of subjects to be processed from first subject id')
    parser.add_argument('--allowlist', '-l', action='store', help='path to subject allowlist')

    parser.add_argument('--timeframe', '-t', type=int, action='store', help='timeframe to be processed')

    args, _ = parser.parse_known_args()

    cfg = configparser.ConfigParser()
    cfg.read('config.ini')

    data_dir = args.data_dir if args.data_dir else cfg[args.profile]['DataDir']

    start_time = time.time()

    # You should have the subject ID as a folder name for each subject on the data_dir and no
    # other files or folders on data_dir
    if args.allowlist and os.path.exists(args.allowlist):
        with open(args.allowlist) as f:
            sids = [n for n in f.read().splitlines() if os.path.isdir(os.path.join(data_dir, n))]
    else:
        sids = [n for n in os.listdir(data_dir) if os.path.isdir(os.path.join(data_dir, n))]

    if args.all:
        subject_ids = sorted(sids)
    elif args.subject:
        sid = args.subject
        if sid in sids:
            subject_ids = [sid]
        else:
            subject_ids = []
    elif args.start is not None and args.start >= 0 and args.start < len(sids):
        if args.number is not None and args.number > 0:
            end = args.start + args.number - 1
            subject_ids = sorted(sids)[args.start:end+1]
        else:
            subject_ids = sorted(sids)[args.start:]
    else:
        subject_ids = []

    log_filename = os.path.join(data_dir, f'surface-{args.job}.log')
    formatter = logging.Formatter(fmt='%(asctime)s | %(name)s | %(levelname)s | %(message)s')
    handler = logging.FileHandler(log_filename)
    handler.setFormatter(formatter)
    logger.addHandler(handler)

    for subject_id in subject_ids:
        logger.debug(f"Processing subject {subject_id}...")

        i_dir = os.path.join(data_dir, subject_id, f'Instance_{args.instance}')

        if not os.path.exists(i_dir):
            logger.debug(f'Instance_{args.instance} directory does not exist for {subject_id}')
            continue

        input_dir = os.path.join(i_dir, args.output_dir)

        save_mesh_as_vtk('./model', input_dir, args.timeframe, args.force)

        logger.debug("VTK_mesh done!")
        logger.debug('TOTAL TIME: {}'.format(time.time() - start_time))


if __name__ == '__main__':
    main()
